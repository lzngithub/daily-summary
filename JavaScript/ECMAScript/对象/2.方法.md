# 对象基本方法

说明：

- Object.function()：这种形式的是静态方法，调用方式为构造函数 Object 直接调用。
- Object.prototype.function()：这种形式是原型上的方法，调用方式是实例调用。

## Object.assign()

浅拷贝，拷贝第一层, 同属性会进行覆盖, 目标对象会改变

用法：

```js
const returnObj = Ojbect.assign(target, ...sources);
```

例子：

```js
const obj1 = { a: 1, b: 2, c: 3 };
const obj2 = { a: 2, c: 3, d: 4 };
const obj3 = { a: 3, e: 5 };
const returnObj = Object.assign({}, obj1, obj2, obj3);
console.log(returnObj); // {a: 3, b: 2, c: 3, d: 4, e: 5}
```

## Object.defineProperty() / Object.defineProperties()

在一个对象上新增或修改属性，并返回该对象。

默认情况下，使用 Object.defineProperty() 添加的属性是不可写、不可枚举和不可配置的

语法：

```js
Ojbect.defineProperty(objcet, prop, descriptor);
```

参数：

- obj：要定义属性阿对象。
- prop：一个字符串或 Symbol，指定了要定义或修改的属性键。
- descriptor：要定义或修改的属性的描述符。

返回值

- 传入函数的对象，其指定的属性已被添加或修改。

属性描述符

属性描述符是一个对象，分两种，数据描述符，访问器描述符，同时只能是其中的一种类型。

数据描述符和访问器描述符都是对象。它们共享以下可选键

- enumerable：是否可遍历， 默认为 false
- configurable: 配置是否可改，默认为 false

数据描述符还具有以下可选键值：

- value：值,默认 undefined
- writable：是否可写,默认为 false

访问器描述符还具有以下可选键值：

- get: 作为属性的 getter 函数，默认为 undefined
- set： 作为该属性的 setter 函数，默认为 undefined

Object.defineProperty()例子

```js
const object1 = {};
Object.defineProperty(object1, 'property1', {
  value: 42,
  writable: false,
});
object1.property1 = 77;
// Throws an error in strict mode
console.log(object1.property1);
// Expected output: 42
```

Object.defineProperties()例子：

```js
const object1 = {};

Object.defineProperties(object1, {
  property1: {
    value: 42,
    writable: true,
  },
  property2: {},
});

console.log(object1.property1);
// Expected output: 42
```

## Object.getPrototypeOf()/Object.setPrototypeOf()

返回/设置对象的原型

## Object.prototype.isPrototypeOf()

方法用于检查一个对象是否存在于另一个对象的原型链中。跟 instanceof 方法差不多的，用法稍微有些区别。

语法：

```js
isPrototypeOf(object);
```

- object: 要搜索其原型链的对象。
- 返回值：一个布尔值，指示调用 isPrototypeOf() 方法的对象（即 this）是否位于 object 的原型链中。当 object 不是一个对象（即基本类型）时，直接返回 false。

使用

```js
Bar.prototype.isPrototypeOf(bar); // Bar是否在bar的原型链上
```

instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。

- 语法：object instanceof constructor
- 参数：object（要检测的对象.）constructor（某个构造函数）
- 描述：instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。

```js
function Foo() {}
let foo = new Foo();
console.log(foo instanceof Foo); //false
console.log({} instanceof Array); //false
console.log([] instanceof Array); //true
console.log([] instanceof Object); //true
```

## Object.hasOwn() / Object.prototype.hasOwnProperty()

如果指定的对象自身有指定的属性，则静态方法 Object.hasOwn() 返回 true。如果属性是继承的或者不存在，该方法返回 false。

> Object.hasOwn() 旨在取代 Object.prototype.hasOwnProperty()。

语法：

```js
Object.hasOwn(obj, prop);
obj.hasOwnProperty(prop);
```

- obj：要测试的 JavaScript 实例对象。
- prop：要测试属性的 String 类型的名称或者 Symbol。
- 返回值：如果指定的对象中直接定义了指定的属性，则返回 true；否则返回 false。

指示对象自身属性中是否具有指定的属性

例子：

```js
const object1 = {};
object1.property1 = 42;
console.log(Object.hasOwn(object1, 'property1')); // true
console.log(object1.hasOwnProperty('property1')); // true
```

## Object.entries()/Object.keys()/Object.values()

将对象的转换为数组

## Object.fromEntries()

Object.fromEntries() 静态方法将键值对列表转换为一个对象，是 Object.entries()的逆操作。

```js
const entries = new Map([
  ['foo', 'bar'],
  ['baz', 42],
]);

const obj = Object.fromEntries(entries);

console.log(obj);
// Expected output: Object { foo: "bar", baz: 42 }
```
