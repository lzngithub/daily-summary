# 二叉搜索树

左节点树的所有节点都比根节点小，右节点树的所有节点都比根节点大

构建一棵二叉搜索树（BST）

## 构建基本结构

```js
function TreeNode(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}
class BinarySearchTree {
  constructor() {
    this.root = null;
  }
}
```

插入节点

```js
class BinarySearchTree {
  constructor() {
    this.root = null;
  }
  insert(value) {
    const insertNode = (node, newNode) => {
      if (newNode.value < node.value) {
        if (node.left) {
          insertNode(node.left, newNode);
        } else {
          node.left = newNode;
        }
      } else {
        if (node.right) {
          insertNode(node.right, newNode);
        } else {
          node.right = newNode;
        }
      }
    };

    let Node = new TreeNode(value);
    if (this.root) {
      insertNode(this.root, Node);
    } else {
      this.root = Node;
    }
  }
}
```

查找最大最小值

```js
class BinarySearchTree {
  constructor() {
    this.root = null;
  }
  min(current = this.root) {
    while (current.left) {
      current = current.left;
    }
    return current.value;
  }
  max(current = this.root) {
    while (current.right) {
      current = current.right;
    }
    return current.value;
  }
}
```

删除节点

```js
remove(value) {
  this.root = removeNode(this.root, value);
  function removeNode(node, value) {
    if (!node) return null;
    if (value === node.value) {
      if (node.left && node.right) {
        node.value = this.min(node.right);
        node.right = removeNode(node.right, node.value);
      } else {
        return node.left ?? node.right;
      }
    } else {
      let currentNode = value < node.value ? "left" : "right";
      node[currentNode] = removeNode(node[currentNode], value);
    }
    return node;
  }
}
```
