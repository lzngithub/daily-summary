# 树

树是用来模拟具有树状结构性质的数据集合。

由 n（n > 1）个有限节点组成一个有层次关系的集合，具有以下特点

- 1）每个节点有 0 个或者多个子节点
- 2）没有父节点的节点叫做根节点
- 3）每一个非跟节点有且只有一个根节点

## 树的分类

数的分类：平衡二叉树，红黑树，B 树，B+树，都是从二叉树演变来的。

树的分类有多种，根据子节点的数量不同，可分为二叉树、三叉树或多叉树。最常见的是二叉树，每个节点最多有两个子节点，所以掌握二叉树是比较重要的。多叉树常见的有字典树。 对于二叉树，根据节点的排列和数量，

- 二叉搜索树：左节点比根节点小，右节点比跟节点大
- 完满二叉树：除了叶子结点之外的每一个结点都有两个孩子结点。
- 完全二叉树：除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐。
- 完美二叉树：除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充。

## 二叉树的常见概念

- 二叉树的特点：每个节点最多有两棵子树
- 二叉树的深度：二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

## 二叉树的遍历

从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次

- 先序遍历 : 根结点 -> 左子树 -> 右子树
- 中序遍历 : 左子树 -> 根结点 -> 右子树
- 后序遍历 : 左子树 -> 右子树 -> 根结点

在这三种顺序中，根结点的遍历分别被安排在了首要位置、中间位置和最后位置。所谓的“先序”、“中序”和“后序”，“先”、“中”、“后”其实就是指根结点的遍历时机。

先定义一个二叉树数据结构

```js
const tree = {
  value: "A",
  left: {
    value: "B",
    left: null,
    right: {
      value: "D",
      left: {
        value: "F",
        left: null,
        right: null,
      },
      right: null,
    },
  },
  right: {
    value: "C",
    left: null,
    right: {
      value: "E",
      left: {
        value: "G",
        left: {
          value: "H",
          left: null,
          right: null,
        },
        right: {
          value: "I",
          left: null,
          right: null,
        },
      },
    },
  },
};
```

### 递归遍历

#### 1.1 前序遍历

```js
function beforeOrder(root) {
  if (!root) {
    return;
  }
  console.log(root.value);
  beforeOrder(root.left);
  beforeOrder(root.right);
}
```

#### 1.2 中序遍历

```js
function middleOrder(root) {
  if (!root) {
    return;
  }
  middleOrder(root.left);
  console.log(root.value);
  middleOrder(root.right);
}
```

#### 1.3 后序遍历

```js
function afterOrder(root) {
  if (!root) {
    return;
  }
  afterOrder(root.left);
  afterOrder(root.right);
  console.log(root.value);
}
```

### 迭代遍历

迭代遍历可以用栈来做

#### 2.1 先序遍历

```js
function beforeSearch(root) {
  if (!root) return;
  const result = [];
  const stack = [];
  stack.push(root);
  while (stack.length) {
    const currentNode = stack.pop();
    result.push(currentNode.value);
    if (currentNode.right) stack.push(currentNode.right);
    if (currentNode.left) stack.push(currentNode.left);
  }
  return result;
}
```

#### 2.2 中序遍历

```js
function middleSearch(root) {
  if (!root) return;
  const result = [];
  const stack = [];
  let current = root;
  while (current || stack.length) {
    // 入栈
    while (current) {
      stack.push(current);
      current = current.left;
    }
    // 出栈
    current = stack.pop();
    result.push(current.value);
    // 开启新的一轮入栈
    current = current.right;
  }
  return result;
}
```

#### 2.3 后序遍历

```js
function afterSearch(root) {
  if (!root) return;
  const result = [];
  const stack = [];
  stack.push(root);
  while (stack.length) {
    const currentNode = stack.pop();
    result.unshift(currentNode.value);
    if (currentNode.left) stack.push(currentNode.left);
    if (currentNode.right) stack.push(currentNode.right);
  }
  return result;
}
```

#### 2.4 层序遍历

适合用队列，不适合用栈

```js
function levelOrder(root) {
  if (!root) return;
  let result = [];
  let queue = [];
  queue.push(root);
  while (queue.length) {
    const level = [];
    const len = queue.length;
    console.log(queue);
    for (let i = 0; i < len; i++) {
      currentNode = queue.shift();
      level.push(currentNode.value);
      if (currentNode.left) queue.push(currentNode.left);
      if (currentNode.right) queue.push(currentNode.right);
    }
    result.push(level);
  }
  return result;
}
```
