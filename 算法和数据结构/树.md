# 树

树是用来模拟具有树状结构性质的数据集合。

由 n（n > 1）个有限节点组成一个有层次关系的集合，具有以下特点

- 1）每个节点有 0 个或者多个子节点
- 2）没有父节点的节点叫做根节点
- 3）每一个非跟节点有且只有一个根节点

## 树的分类

数的分类：平衡二叉树，红黑树，B 树，B+树，都是从二叉树演变来的。

树的分类有多种，根据子节点的数量不同，可分为二叉树、三叉树或多叉树。最常见的是二叉树，每个节点最多有两个子节点，所以掌握二叉树是比较重要的。多叉树常见的有字典树。 对于二叉树，根据节点的排列和数量，

- 二叉搜索树：左节点比根节点小，右节点比跟节点大
- 完满二叉树：除了叶子结点之外的每一个结点都有两个孩子结点。
- 完全二叉树：除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐。
- 完美二叉树：除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充。

## 二叉树的常见概念

- 二叉树的特点：每个节点最多有两棵子树
- 二叉树的深度：二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

## 二叉树的遍历

从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次

- 先序遍历 : 根结点 -> 左子树 -> 右子树
- 中序遍历 : 左子树 -> 根结点 -> 右子树
- 后序遍历 : 左子树 -> 右子树 -> 根结点

在这三种顺序中，根结点的遍历分别被安排在了首要位置、中间位置和最后位置。所谓的“先序”、“中序”和“后序”，“先”、“中”、“后”其实就是指根结点的遍历时机。

先定义一个二叉树数据结构

```js
const tree = {
  value: "A",
  left: {
    value: "B",
    left: null,
    right: {
      value: "D",
      left: {
        value: "F",
        left: null,
        right: null,
      },
      right: null,
    },
  },
  right: {
    value: "C",
    left: null,
    right: {
      value: "E",
      left: {
        value: "G",
        left: {
          value: "H",
          left: null,
          right: null,
        },
        right: {
          value: "I",
          left: null,
          right: null,
        },
      },
    },
  },
};
```

### 递归遍历

#### 1.1 前序遍历

```js
function beforeOrder(root) {
  if (!root) {
    return;
  }
  console.log(root.value);
  beforeOrder(root.left);
  beforeOrder(root.right);
}
```

#### 1.2 中序遍历

```js
function middleOrder(root) {
  if (!root) {
    return;
  }
  middleOrder(root.left);
  console.log(root.value);
  middleOrder(root.right);
}
```

#### 1.3 后序遍历

```js
function afterOrder(root) {
  if (!root) {
    return;
  }
  afterOrder(root.left);
  afterOrder(root.right);
  console.log(root.value);
}
```

### 迭代遍历

迭代遍历可以用栈来做

#### 2.1 先序遍历

```js
class Stack {
  data = [];
  push(item) {
    return this.data.push(item);
  }
  pop() {
    return this.data.pop();
  }
}

function beforeSearch(root) {
  if (!root) return;
  let currentNode = root;
  let stack = new Stack();
  while (currentNode) {
    console.log(currentNode.value);
    if (currentNode.left && currentNode.right) {
      stack.push(currentNode.right);
      currentNode = currentNode.left;
    } else if (currentNode.left) {
      currentNode = currentNode.left;
    } else if (currentNode.right) {
      currentNode = currentNode.right;
    } else {
      currentNode = stack.pop();
    }
  }
}
```

#### 2.2 中序遍历

```js
function MiddleSearch(root) {
  if (!root) return;
  let currentNode = root;
  let stack = new Stack();
  while (currentNode) {
    if (currentNode.left) {
      stack.push(currentNode);
      currentNode = currentNode.left;
    } else {
      console.log(currentNode.value);
      if (currentNode.right) {
        currentNode = currentNode.right;
      } else {
        let isAgain = true;
        while (isAgain) {
          currentNode = stack.pop();
          console.log(currentNode.value);
          if (currentNode.right) {
            currentNode = currentNode.right;
            isAgain = false;
          } else {
            if (stack.isEmpty()) {
              isAgain = false;
              currentNode = null;
            } else {
              isAgain = true;
            }
          }
        }
      }
    }
  }
}
```

#### 2.3 后序遍历

```js
function afterSearch(root) {
  if (!root) return;
  let currentNode = root;
  let stack = new Stack();
  while (currentNode) {
    if (currentNode.left) {
      stack.push(currentNode);
      currentNode = currentNode.left;
    } else if (currentNode.right) {
      stack.push(currentNode);
      currentNode = currentNode.right;
    } else {
      console.log(currentNode.value);
      let isAgain = true;
      while (isAgain) {
        const isRight = currentNode === stack.peek().right;
        currentNode = stack.pop();
        if (isRight) {
          console.log(currentNode.value);
          if (stack.isEmpty()) {
            isAgain = false;
            currentNode = null;
          } else {
            isAgain = true;
          }
        } else if (currentNode.left && currentNode.right) {
          stack.push(currentNode);
          currentNode = currentNode.right;
          isAgain = false;
        } else {
          console.log(currentNode.value);
          if (stack.isEmpty()) {
            isAgain = false;
            currentNode = null;
          } else {
            isAgain = true;
          }
        }
      }
    }
  }
}
```
