# http 缓存

http 缓存分两种，强制缓存和协商缓存。缓存只针对文件有效，意思就是只针对静态资源。

## 强制缓存

所谓强缓存，可以理解为强制缓存的意思，即浏览器在访问某个资源时会判断是否使用本地缓存里已经存在的资源文件，使用本地缓存的话则不会发送请求到服务器，从而达到减轻服务器访问压力的作用，且由于直接从本地缓存读取资源文件，大大提高了加载速度。

单向的配置，客户端和服务端都可以配置，但一般是服务端配置，就是说是配置在 response header 中的，主要有两个字段 Expires 和 cache-control 去进行控制，分别对应 http1.0 和 http1.1。

### cache-control

浏览器第一次请求远程服务器的某个资源时，如果服务器希望浏览器得到该资源后一段时间内不要再发送请求过来，直接从浏览器里的缓存里取，则服务器可以通过在响应头里设置 Cache-Control: max-age=31536000，max-age 代表缓存时间，单位为秒，这里的数据换算过来就是一年，意味着在一年内浏览器不会再向服务器发送请求。

cache-control: 缓存响应指令，可以有多个，用逗号隔开;

- no-store：不使用任何形式的缓存。具有 HTTP 缓存的最高优先级。
- no-cache：不使用强制缓存。每次进行响应前都向服务器进行缓存有效性验证。
- public：公共缓存。任何从源服务器到客户端中的每个节点都可以对资源进行缓存。
- private：私有缓存。仅客户端可以对资源进行缓存。
- max-age：客户端缓存存储的最长时间，单位秒。判断的优先级高于 Expires，客户端会判断资源已缓存的时长是否小于设置的 max-age 时长。是则直接使用缓存数据，否则会进行 Expires 的判断流程（这个是常用的）。
- s-maxage：代理缓存服务器最长的缓存时间，单位秒。优先级高于 max-age 和 Expires，仅适用于缓存服务器。

### Expires

强缓存除了使用 Cache-Control 实现之外，还可以使用 Expires 字段，Expires 是 Http1.0 规范，Cache-Control 是 Http1.1 规范，Expires 返回一个具体的时间值（如下图所示），代表缓存的有效期，在该日期内浏览器不会向服务器发起请求，而是直接从缓存里获取资源。

### 强缓存总结

怎么判断是不是使用强缓存呢，空接口请求中返回的状态码：

1. 200（from disk cache）：硬盘缓存，tab 关闭数据还在，一般存放大文件。
2. 200（from memory cache）：内存缓存，tab 关闭就没有了，生命周期短，读取会比较快。

一般来说，浏览器会将较大的资源缓存到 disk cache，而较小的资源则被缓存到 memory cache 里。内存缓存与磁盘缓存相比，访问速度要更快一些！

- 首先，使用客户端获取的 GMT 时间与服务器 GMT 时间作比较，如果客户端主动修改了系统时间，就会出现缓存命中的误差。
- 其次，GMT 时间是基于格林尼治天文台测算时间后，每隔一小时想全世界发放调时信息。观测本身存在的误差以及非实时的同步机制，都可能会导致出现缓存命中的误差。
- Cache-control 的优先级要高于 Expires，如果两者同时设置，会优先使用 Cache-control 而忽略掉 Expires。

## 协商缓存

客户端缓存失效后会向服务器进行进行缓存有效性验证，这个缓存有效性验证的过程就是协商缓存。若资源有效，则返回 304（Not Modified）。客户端拿到 304 状态码后会再从本地缓存中获取资源。整个请求响应过程是与无缓存流程一样的。相对于无缓存流程的优势在于仅响应状态码后，客户端直接从本地缓存获取文件，而无需进行文件下载。减少了网络响应的文件大小，进而加快了网络响应速度。

强缓存优先级大于协商缓存，即两者同时存在时，如果强缓存开启且在有效期内，则不会走协商缓存。

协商缓存会先判断请求头中是否携带 no-store。如果携带，则直接返回最新的服务器文件。

### HTTP/1.1 - ETag

浏览器初次请求资源，服务器返回资源，同时生成一个 Etag 值携带在响应头里返回给浏览器，当浏览器再次请求资源时会在请求头里携带 If-None-Match，值是之前服务器返回的 Etag 的值，服务器收到之后拿该值与资源文件最新的 Etag 值做对比。

- 如果没有变化则返回 304，告诉浏览器继续使用缓存（不返回资源文件）。
- 如果发生变化，则返回 200 和最新的资源文件给浏览器使用。

ETag 的值没有规定，一般是文件 hash，也可以是版本号等。

除了 Etag 外，还有一个 Last-Modified 的属性，它是 Http1.0 规范的，服务器返回 Last-Modified，浏览器请求头对应携带的是 If-Modified-since，与 Etag 不同的是，Last-Modified 的值是一个时间值，代表文件的修改时间，服务器通过对比文件的修改时间是否发生改变来判断是否使用缓存。

### HTTP/1.0 - Last-Modified

- Last-Modified：响应头携带的资源最后修改时间。格式为 last-modified:GMT。
- If-Modified-Since：请求头携带的资源是否在某个时间后有修改。服务器会使用此值和其本身存储的时间进行比较。格式为：If-Modified-Since:GMT。只可以用在 GET 或 HEAD 请求中。
- If-Unmodified-Since：请求头携带的资源是否在某个时间后没有修改。格式为：if-unmodified-since:GMT 。有别于 If-Modified-Since，If-Unmodified-Since 被用于 POST 或其他非简单请求。如果在 If-Unmodified-Since 指定的时间内有过修改，则返回 412(Precondition Failed)。

### 协商缓存总结

相比 Last-Modified，Etag 优先级更高，使用上也更精确一些，因为有时候会存在文件内容并没有改变，但文件的修改时间变更了，Last-Modified 不一致所以服务器会重新返回资源文件，实际上还是可以继续使用缓存的。

## 用户行为对缓存的影响

经过实践，以下方式都不会导致强缓存失效即命中强缓存还是会从缓存中去取。

1.重新输入地址，地址栏回车，导航栏切换，普通刷新（F5），重新打开一个 Tab 页或者从收藏夹里进入页面，新开页面和普通刷新对缓存是没有影响的。

2.强制刷新

强制刷新后一些静态资源文件都是重新加载，不在走强缓存，走协商缓存，但是发现个别静态资源文件，比如 logo 图片这种还是会走强缓存。

3.清除缓存强制刷新

资源请求都是 200，强缓存和协商缓存失效

## 总结

通过前文，我们了解到 HTTP 缓存主要分：强制缓存、协商缓存。
强制缓存由 Exipres（HTTP/1.0）、 Cache-Control（HTTP/1.1）控制。客户端直接读本地缓存，不会再跟服务器端交互，状态码 200。

协商缓存由 Last-Modified / If-Modified-Since（HTTP/1.0）， Etag /If-None-Match（HTTP/1.1）进行有效性验证，每次请求需要让服务器判断一下资源是否更新过，从而决定客户端是否使用缓存，如果是，则返回 304，否则返回最新文件。

HTTP/2.0 中设计了新的缓存方式，服务器推送（Push Server）。有别于强制缓存和协商缓存，属于推送缓存。这种新的缓存方式主要是为了解决客户端缓存时效性的问题，即还没有收到客户端的请求，服务器就把各种资源推送给客户端。比如，客户端只请求了 a.html，但是服务器把 a.html、a.css、a.png 全部发送给客户端。这样的话，只需要一次请求，客户端就更新了所有文件的缓存，提高了缓存的时效性。

### 使用场景

因为现在大部分的 web 端应用的 spa 应用，对于 spa 应用，打包过后的文件为 index.html、css、js、img 文件等，

- index.html 是应用的入口，只有加载它之后才会加载它引用的资源文件，index.html 应该不缓存，或者是设置 no-cache 的强缓存（即资源被缓存，但立即失效，下次请求会验证资源是否过期）+ 协商缓存，保证 index.html 每次都从服务器获取最新的；
- js、css、img 等文件会在打包后生成对应的 hash 标识，不必担心缓存后重新部署资源不更新，所以这些文件可以设置一个比较长的缓存时间.
