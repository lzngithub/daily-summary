# 防抖与节流

防抖和节流都是为了解决回调函数高频触发的问题，比如滑动屏幕触发的回调函数，输入框输入字符触发的回调函数等场景。

## 函数防抖

> 在函数被触发后计时延迟处理，如果在该时间段内再次触发，则重新计时

通俗解释：抖动，我们可以联想到相机抖动，手抖动等场景，当抖动的时候我们去做一些事情有时候是不太好的，比如抖动的时候拍照片，因此需要等稳定下来，再去做就会好一点。函数防抖也是这样设计的，当事件触发的时候，也不要着急去执行相应的方法，等一段时间，如果这段时间该事件不再触发，也就是不再抖动，我们才去执行相应的方法，如果在等待的这段事件内该事件再次触发，就证明还在抖动，还不稳定，就继续重新等待。

特点：因此在规定时间内只有最后一次触发的回调函数生效

代码思路：事件触发，开启定时器规定一个时间，规定时间结束后执行回调函数；如果在规定时间内事件再次触发，清除定时器，重新开始一个新的定时器。

简单实现（没考虑超时取消的问题，以及特殊场景的 this 指向问题）

```js
// 全部用箭头函数，注意this指向问题
const debounce = (fn, delay) => {
  // 事件触发
  let timer = null;
  return (...params) => {
    // 规定时间内再次触发则清除定时器
    if (timer) clearTimeout(timer);
    // 重新设定定时器
    timer = setTimeout(() => {
      // 规定时间到，执行回调函数同时清除定时器
      fn(...params);
      clearTimeout(timer);
    }, delay);
  };
};
```

## 函数节流

> 在规定时间段内回调函数多次被触发，只有一次会生效

通俗解释：节流，联想水流，节流就是让水变得缓一点，从源头控制，无论来多少，在规定时间段内，就控制只能有特定量的水能进入，用一个阀门控制。

特点：在规定时间内，无论触发多少次，只有在规定时间内的一次生效。

思路：事件触发，执行操作，阀门关闭，阀门关闭期间触发不执行操作，一段时间后阀门再次开启，操作可再次触发。

简单实现（没考虑超时取消的问题，以及特殊场景的 this 指向问题）

```js
// 节流函数
const throttle = (fn, delay) => {
  let record = null;
  return (...content) => {
    // 事件触发
    if (!record) {
      // 阀门开启才能执行操作
      // 关闭阀门
      record = setTimeout(() => {
        // 执行操作
        fn(...content);
        // 阀门开启
        clearTimeout(record);
        record = null;
      }, delay);
    }
  };
};
```

## 总结

防抖和节流是两种解决短时间事件触发频率过高问题的思路。

防抖是动态的，只有当最后一次事件触发结束之后，才会执行处理函数。中间没有处理过函数，防止了页面"抖动"，可以认为保证了过程的连续平滑。

节流是离散的，明确对时间进行了分割，在指定的时间块中只执行一次事件处理函数。

从降低 CPU 计算频次来说，debounce 效果更好，因为它在整个高频回调期间，只会触发一次。

但 debounce 计算频次少，带来的影响就是可能会损失用户的体验。比如如果在 scrollViewDidScroll 中使用了 debounce 来触发某些渲染逻辑，那么用户如果一直在滚动屏幕，只有在用户松手后，才能把屏幕渲染出来，整个滚动过程是无法加载的。

节流函数涉及到传值的一些问题的时候，如果传的是原始值的话，有可能造成最后一次的值丢失，比如输入框用户输入的时候。

了解两者实现，区别和各自的特点，在合适的场景选择使用合适的方法就好。

下面一些是我推荐使用的场景，可能有误，参考就好，具体业务场景具体分析

防抖：

- 输入框输入查询，结束输入前都不打算去请求后端接口。
- 视口大小变化做自适应的时候的

节流：

- 下滑加载更多
- dom 元素拖动需要实时计算一些值
- 滚动条滚动的时候需要去做一些操作
