# 防抖与节流

防抖和节流都是为了解决回调函数高频触发的问题，比如滑动屏幕触发的回调函数，输入框输入字符触发的回调函数等场景。

## 函数防抖

> 在函数被触发后延迟某个时间段后触发回调函数，如果在该时间段内再次触发，则重新计时

特点：延后执行，只要在规定时间内再次触发，就会则清除定时器，重新开始新的定时器，因此在规定时间内只有最后一次触发的回调函数生效

代码思路：事件触发，开启定时器规定一个时间，规定时间结束后执行回调函数，如果在规定时间内事件再次触发，则清除定时器，重新开始一个新的定时器。

简单实现

```js
// 全部用箭头函数，注意this指向问题
const debounce = (fn, delay) => {
  let timer = null;
  return (...params) => {
    // 清除定时器
    if (timer) clearTimeout(timer);
    // 重新设定定时器
    timer = setTimeout(() => {
      fn(...params);
      clearTimeout(timer);
    }, delay);
  };
};
```

## 函数节流

> 在规定时间段内回调函数多次被触发，只有在规定时间内的第一次会生效

特点：在规定时间内，无论触发多少次，只有在规定时间内的第一次生效。

思路：事件触发，开启定时器规定一个时间，规定时间结束后执行回调函数，规定时间内触发的事件都不执行回调函数，直到规定时间结束，清除定时器，同时接受再次设置定时器。

简单实现

```js
// 节流函数
const throttle = (fn, delay) => {
  let record = null;
  return (...content) => {
    if (!record) {
      record = setTimeout(() => {
        fn(...content);
        clearTimeout(record);
        record = null;
      }, delay);
    }
  };
};
```

## 总结

防抖和节流是两种解决短时间事件触发频率过高问题的思路，防抖是动态的，只有当最后一次事件触发结束之后，才会执行处理函数。中间没有处理过函数，防止了页面"抖动"，可以认为保证了过程的连续平滑。

而节流是离散的，明确对时间进行了分割，在指定的时间块中只执行一次事件处理函数。

从降低 CPU 计算频次来说，debounce 效果更好，因为它在整个高频回调期间，只会触发一次。

但 debounce 计算频次少，带来的影响就是可能会损失用户的体验。比如如果在 scrollViewDidScroll 中使用了 debounce 来触发某些渲染逻辑，那么用户如果一直在滚动屏幕，只有在用户松手后，才能把屏幕渲染出来，整个滚动过程是无法加载的。

节流函数涉及到传值的一些问题的时候，如果传的是原始值的话，有可能造成最后一次的值丢失，比如输入框用户输入的时候。
